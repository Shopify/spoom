# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ansi` gem.
# Please instead update this file by running `bin/tapioca gem ansi`.

# ANSI namespace module contains all the ANSI related classes.
#
# source://ansi//lib/ansi.rb#2
module ANSI
  extend ::ANSI::Constants
  extend ::ANSI::Code

  class << self
    # Check metadata for missing constants.
    #
    # source://ansi//lib/ansi/version.rb#11
    def const_missing(name); end

    # Returns Hash table of project metadata.
    #
    # source://ansi//lib/ansi/version.rb#3
    def metadata; end

    # Create a new Ansi::String object.
    #
    # source://ansi//lib/ansi/string.rb#5
    def string(str); end
  end
end

# The BBCode module helps ease the separation of core and frontend with the
# core (or submodules) being still able to say, what colors shall be used
# in it's responses. This is achieved by encoding formatting information
# using the BBCode tokens. This enables you to "pipe" layout information
# such as colors, style, font, size and alignment through the core to
# the frontend.
#
# Additionally it converts markups/codes between ANSI, HTML and BBCode
# almost freely ;)
#
#   # Converting a bbcode string to ANSI and XHTML
#   str = "this is [COLOR=red]red[/COLOR], this is [B]bold[/B]"
#   print( BBCode.bbcode_to_ansi(str) )
#   print( BBCode.bbcode_to_html(str) )
#
# source://ansi//lib/ansi/bbcode.rb#32
module ANSI::BBCode
  class << self
    # Returns the ANSI sequence for given color, if existant
    #
    # source://ansi//lib/ansi/bbcode.rb#88
    def ansi(colorname); end

    # Returns the string with all ansi escape sequences converted to BBCodes
    #
    # source://ansi//lib/ansi/bbcode.rb#101
    def ansi_to_bbcode(string); end

    # Converts an ANSI string to one with HTML markup.
    # Returns the string with ANSI code sequences converted to XHTML markup.
    #
    # source://ansi//lib/ansi/bbcode.rb#316
    def ansi_to_html(string); end

    # Converts a BBCode string to one with ANSI sequences.
    # Returns the string with all formatting instructions in BBCodes converted
    # to ANSI code sequences / aligned with spaces to specified width.
    #
    # source://ansi//lib/ansi/bbcode.rb#144
    def bbcode_to_ansi(string, usecolors = T.unsafe(nil)); end

    # Converts a BBCode string to one with HTML markup.
    # Returns the string with all formatting instructions in
    # BBCodes converted to XHTML markups.
    #
    # source://ansi//lib/ansi/bbcode.rb#251
    def bbcode_to_html(string); end

    # Returns the (X)HTML markup code as ANSI sequences
    #
    # source://ansi//lib/ansi/bbcode.rb#324
    def html_to_ansi(string); end

    # Converts a HTML string into one with BBCode markup (TODO)
    # Returns the (X)HTML markup string as BBCode
    #
    # source://ansi//lib/ansi/bbcode.rb#192
    def html_to_bbcode(string); end

    # --- strip_bbcode( string )
    # Will strip any BBCode tags from the given string.
    #
    # source://ansi//lib/ansi/bbcode.rb#95
    def strip_bbcode(string); end
  end
end

# ANSInames => BBCode LUT
#
# source://ansi//lib/ansi/bbcode.rb#72
ANSI::BBCode::ANSINAME2BBCODE = T.let(T.unsafe(nil), Hash)

# ANSIname => ANSIcode LUT
#
# source://ansi//lib/ansi/bbcode.rb#35
ANSI::BBCode::ANSINAME2CODE = T.let(T.unsafe(nil), Hash)

# BBColor => ANSIname LUT
#
# source://ansi//lib/ansi/bbcode.rb#53
ANSI::BBCode::BBCOLOR2ANSI = T.let(T.unsafe(nil), Hash)

# Table of codes used throughout the system.
#
# @see http://en.wikipedia.org/wiki/ANSI_escape_code
#
# source://ansi//lib/ansi/chart.rb#6
ANSI::CHART = T.let(T.unsafe(nil), Hash)

# ANSI::Chain was inspired by Kazuyoshi Tlacaelel's Isna library.
#
# source://ansi//lib/ansi/chain.rb#7
class ANSI::Chain
  # @return [Chain] a new instance of Chain
  #
  # source://ansi//lib/ansi/chain.rb#10
  def initialize(string); end

  # Returns the value of attribute codes.
  #
  # source://ansi//lib/ansi/chain.rb#19
  def codes; end

  # source://ansi//lib/ansi/chain.rb#22
  def method_missing(s, *a, &b); end

  # Returns the value of attribute string.
  #
  # source://ansi//lib/ansi/chain.rb#16
  def string; end

  # source://ansi//lib/ansi/chain.rb#32
  def to_s; end

  # source://ansi//lib/ansi/chain.rb#43
  def to_str; end
end

# ANSI Codes
#
# Ansi::Code module makes it very easy to use ANSI codes.
# These are especially nice for beautifying shell output.
#
#   Ansi::Code.red + "Hello" + Ansi::Code.blue + "World"
#   => "\e[31mHello\e[34mWorld"
#
#   Ansi::Code.red{ "Hello" } + Ansi::Code.blue{ "World" }
#   => "\e[31mHello\e[0m\e[34mWorld\e[0m"
#
# IMPORTANT! Do not mixin Ansi::Code, instead use {ANSI::Mixin}.
#
# See {ANSI::CHART} for list of all supported codes.
#
# source://ansi//lib/ansi/code.rb#37
module ANSI::Code
  include ::ANSI::Constants
  extend ::ANSI::Constants
  extend ::ANSI::Code

  # Return ANSI code given a list of symbolic names.
  #
  # source://ansi//lib/ansi/code.rb#60
  def [](*codes); end

  # Apply ANSI codes to a first argument or block value.
  #
  # @example
  #   ansi("Valentine", :red, :on_white)
  # @example
  #   ansi(:red, :on_white){ "Valentine" }
  # @return [String] String wrapped ANSI code.
  #
  # source://ansi//lib/ansi/code.rb#176
  def ansi(*codes); end

  # Move cursor left a specified number of spaces.
  #
  # source://ansi//lib/ansi/code.rb#149
  def back(spaces = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def black_on_yellow(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def blue_on_yellow(string = T.unsafe(nil)); end

  # Look-up code from chart, or if Integer simply pass through.
  # Also resolves :random and :on_random.
  #
  # @param codes [Array<Symbol,Integer]
  # Symbols or integers to convert to ANSI code.] odes [Array<Symbol,Integer]
  #   Symbols or integers to convert to ANSI code.
  # @return [String] ANSI code
  #
  # source://ansi//lib/ansi/code.rb#241
  def code(*codes); end

  # Apply ANSI codes to a first argument or block value.
  # Alternate term for #ansi.
  #
  # @deprecated May change in future definition.
  # @example
  #   ansi("Valentine", :red, :on_white)
  # @example
  #   ansi(:red, :on_white){ "Valentine" }
  # @return [String] String wrapped ANSI code.
  #
  # source://ansi//lib/ansi/code.rb#176
  def color(*codes); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def cyan_on_yellow(string = T.unsafe(nil)); end

  # Like +move+ but returns to original position after
  # yielding the block.
  #
  # source://ansi//lib/ansi/code.rb#120
  def display(line, column = T.unsafe(nil)); end

  # Move cursor down a specified number of spaces.
  #
  # source://ansi//lib/ansi/code.rb#144
  def down(spaces = T.unsafe(nil)); end

  # Move cursor right a specified number of spaces.
  #
  # source://ansi//lib/ansi/code.rb#155
  def forward(spaces = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def green_on_yellow(string = T.unsafe(nil)); end

  # Creates an xterm-256 color code from a CSS-style color string.
  #
  # @param string [String] Hex string in CSS style, .e.g. `#5FA0C2`.
  # @param background [Boolean] Use `true` for background color, otherwise foreground color.
  #
  # source://ansi//lib/ansi/code.rb#325
  def hex_code(string, background = T.unsafe(nil)); end

  # Move cursor left a specified number of spaces.
  #
  # source://ansi//lib/ansi/code.rb#149
  def left(spaces = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def magenta_on_yellow(string = T.unsafe(nil)); end

  # Use method missing to dispatch ANSI code methods.
  #
  # source://ansi//lib/ansi/code.rb#89
  def method_missing(code, *args, &blk); end

  # Move cursor to line and column.
  #
  # source://ansi//lib/ansi/code.rb#134
  def move(line, column = T.unsafe(nil)); end

  # Provides a random primary ANSI color.
  #
  # @param background [Boolean] Use `true` for background color, otherwise foreground color.
  # @return [Integer] ANSI color number
  #
  # source://ansi//lib/ansi/code.rb#274
  def random(background = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def red_on_yellow(string = T.unsafe(nil)); end

  # Creates an XTerm 256 color escape code from RGB value(s). The
  # RGB value can be three arguments red, green and blue respectively
  # each from 0 to 255, or the RGB value can be a single CSS-style
  # hex string.
  #
  # @param background [Boolean] Use `true` for background color, otherwise foreground color.
  #
  # source://ansi//lib/ansi/code.rb#286
  def rgb(*args); end

  # Given red, green and blue values between 0 and 255, this method
  # returns the closest XTerm 256 color value.
  #
  # @raise [ArgumentError]
  #
  # source://ansi//lib/ansi/code.rb#335
  def rgb_256(r, g, b); end

  # Creates an xterm-256 color from rgb value.
  #
  # @param background [Boolean] Use `true` for background color, otherwise foreground color.
  #
  # source://ansi//lib/ansi/code.rb#313
  def rgb_code(red, green, blue, background = T.unsafe(nil)); end

  # Move cursor right a specified number of spaces.
  #
  # source://ansi//lib/ansi/code.rb#155
  def right(spaces = T.unsafe(nil)); end

  # Apply ANSI codes to a first argument or block value.
  # Alias for #ansi method.
  #
  # @deprecated Here for backward compatibility.
  # @example
  #   ansi("Valentine", :red, :on_white)
  # @example
  #   ansi(:red, :on_white){ "Valentine" }
  # @return [String] String wrapped ANSI code.
  #
  # source://ansi//lib/ansi/code.rb#176
  def style(*codes); end

  # Remove ANSI codes from string or block value.
  #
  # @param string [String] String from which to remove ANSI codes.
  # @return [String] String wrapped ANSI code.
  #
  # source://ansi//lib/ansi/code.rb#201
  def unansi(string = T.unsafe(nil)); end

  # Remove ANSI codes from string or block value.
  # Alias for unansi.
  #
  # @deprecated May change in future definition.
  # @param string [String] String from which to remove ANSI codes.
  # @return [String] String wrapped ANSI code.
  #
  # source://ansi//lib/ansi/code.rb#201
  def uncolor(string = T.unsafe(nil)); end

  # Remove ANSI codes from string or block value.
  # Alias for #unansi method.
  #
  # @deprecated Here for backwards compatibility.
  # @param string [String] String from which to remove ANSI codes.
  # @return [String] String wrapped ANSI code.
  #
  # source://ansi//lib/ansi/code.rb#201
  def unstyle(string = T.unsafe(nil)); end

  # Move cursor up a specified number of spaces.
  #
  # source://ansi//lib/ansi/code.rb#139
  def up(spaces = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def white_on_yellow(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_black(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_blue(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_cyan(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_green(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_magenta(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_red(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_white(string = T.unsafe(nil)); end

  # source://ansi//lib/ansi/code.rb#70
  def yellow_on_yellow(string = T.unsafe(nil)); end

  class << self
    # List of primary colors.
    #
    # source://ansi//lib/ansi/code.rb#55
    def colors; end

    # List of primary styles.
    #
    # source://ansi//lib/ansi/code.rb#50
    def styles; end
  end
end

# ANSI clear code.
#
# source://ansi//lib/ansi/code.rb#47
ANSI::Code::ENDCODE = T.let(T.unsafe(nil), String)

# Regexp for matching most ANSI codes.
#
# source://ansi//lib/ansi/code.rb#44
ANSI::Code::PATTERN = T.let(T.unsafe(nil), Regexp)

# source://ansi//lib/ansi/columns.rb#6
class ANSI::Columns
  # Create a column-based layout.
  #
  # The +format+ block MUST return ANSI codes.
  #
  # @option options
  # @option options
  # @option options
  # @param list [String, Array] Multiline String or Array of strings to columnize.
  # @param options [Hash] Options to customize columnization.
  # @return [Columns] a new instance of Columns
  #
  # source://ansi//lib/ansi/columns.rb#26
  def initialize(list, options = T.unsafe(nil), &format); end

  # Alignment to apply to cells.
  #
  # source://ansi//lib/ansi/columns.rb#82
  def align; end

  # Set alignment ensuring value is a symbol.
  #
  # @param symbol [#to_sym] Either `:right`, `:left` or `:center`.
  # @raise [ArgumentError]
  # @return [Symbol] The given symbol.
  #
  # source://ansi//lib/ansi/columns.rb#90
  def align=(symbol); end

  # Default number of columns to display. If nil then the number
  # of coumns is estimated from the size of the terminal.
  #
  # source://ansi//lib/ansi/columns.rb#58
  def columns; end

  # Set column count ensuring value is either an integer or nil.
  # The the value given is zero, it will be taken to mean the same
  # as nil, which means fit-to-screen.
  #
  # source://ansi//lib/ansi/columns.rb#63
  def columns=(integer); end

  # Formating to apply to cells.
  #
  # source://ansi//lib/ansi/columns.rb#98
  def format; end

  # Set formatting procedure. The procedure must return
  # ANSI codes, suitable for passing to String#ansi method.
  #
  # source://ansi//lib/ansi/columns.rb#102
  def format=(procedure); end

  # source://ansi//lib/ansi/columns.rb#39
  def inspect; end

  # source://ansi//lib/ansi/columns.rb#116
  def join(cols = T.unsafe(nil)); end

  # List layout into columns. Each new line is taken to be
  # a row-column cell.
  #
  # source://ansi//lib/ansi/columns.rb#45
  def list; end

  # source://ansi//lib/ansi/columns.rb#47
  def list=(list); end

  # Padding size to apply to cells.
  #
  # source://ansi//lib/ansi/columns.rb#69
  def padding; end

  # Set padding to string or number (of spaces).
  #
  # source://ansi//lib/ansi/columns.rb#72
  def padding=(pad); end

  # Return string in column layout. The number of columns is determined
  # by the `columns` property or overriden by +cols+ argument.
  #
  # source://ansi//lib/ansi/columns.rb#111
  def to_s(cols = T.unsafe(nil)); end

  private

  # Used to apply ANSI formatting to each cell.
  #
  # source://ansi//lib/ansi/columns.rb#177
  def ansi_formatting(cell, col, row); end

  # Aligns the cell left or right.
  #
  # source://ansi//lib/ansi/columns.rb#164
  def template(max, pad); end

  # Layout string lines into columns.
  #
  # @todo Put in empty strings for blank cells.
  # @todo Centering look like it's off by one to the right.
  #
  # source://ansi//lib/ansi/columns.rb#127
  def to_s_columns(columns = T.unsafe(nil)); end
end

# Converts {CHART} and {SPECIAL_CHART} entries into constants.
# So for example, the CHART entry for :red becomes:
#
#   ANSI::Constants::RED  #=> "\e[31m"
#
# The ANSI Constants are include into ANSI::Code and can be included
# any where will they would be of use.
#
# source://ansi//lib/ansi/constants.rb#13
module ANSI::Constants; end

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BLACK = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BLINK = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BLINK_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BLUE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BOLD = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BOLD_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BRIGHT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::BRIGHT_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CLEAN = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CLEAR = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLEAR_EOL = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLEAR_LEFT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLEAR_LINE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLEAR_RIGHT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLEAR_SCREEN = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLR = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CLS = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CONCEAL = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CONCEALED = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CONCEAL_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CROSSED_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CROSSED_OUT_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CURSOR_HIDE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::CURSOR_SHOW = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::CYAN = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::DARK = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::DEFAULT_FONT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::DOUBLE_UNDERLINE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ENCIRCLE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ENCIRCLE_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FAINT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT0 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT1 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT2 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT3 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT4 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT5 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT6 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT7 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT8 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT9 = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FONT_DEFAULT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FRAKTUR = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FRAKTUR_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FRAME = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::FRAME_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::GREEN = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::HIDE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::INVERSE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::INVERSE_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::INVERT = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ITALIC = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ITALIC_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::MAGENTA = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::NEGATIVE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_BLACK = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_BLUE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_CYAN = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_GREEN = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_MAGENTA = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_RED = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_WHITE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::ON_YELLOW = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::OVERLINE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::OVERLINE_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::POSITIVE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::RAPID = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::RAPID_BLINK = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::RED = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::RESET = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::RESTORE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::REVEAL = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::REVERSE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#20
ANSI::Constants::SAVE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::SHOW = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::SLOW_BLINK = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::STRIKE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::SWAP = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::UNDERLINE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::UNDERLINE_OFF = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::UNDERSCORE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::WHITE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/constants.rb#16
ANSI::Constants::YELLOW = T.let(T.unsafe(nil), String)

# Diff produces colorized differences of two string or objects.
#
# source://ansi//lib/ansi/diff.rb#7
class ANSI::Diff
  # Setup new Diff object. If the objects given are not Strings
  # and do not have `#to_str` defined to coerce them to such, then
  # their `#inspect` methods are used to convert them to strings
  # for comparison.
  #
  # @param object1 [Object] First object to compare.
  # @param object2 [Object] Second object to compare.
  # @param options [Hash] Options for contoller the way difference is shown. (Not yet used.)
  # @return [Diff] a new instance of Diff
  #
  # source://ansi//lib/ansi/diff.rb#33
  def initialize(object1, object2, options = T.unsafe(nil)); end

  # Returns the first object's difference string.
  #
  # source://ansi//lib/ansi/diff.rb#41
  def diff1; end

  # Returns the second object's difference string.
  #
  # source://ansi//lib/ansi/diff.rb#46
  def diff2; end

  # Returns both first and second difference strings separated by a
  # the given `separator`. The default is `$/`, the record separator.
  #
  # @param separator [String] The string to use as the separtor between the difference strings.
  # @return [String] Joined difference strings.
  #
  # source://ansi//lib/ansi/diff.rb#67
  def join(separator = T.unsafe(nil)); end

  # Returns the first and second difference strings in an array.
  #
  # @return [Array] Both difference strings.
  #
  # source://ansi//lib/ansi/diff.rb#74
  def to_a; end

  # Returns both first and second difference strings separated by a
  # new line character.
  #
  # @return [String] Joined difference strings.
  # @todo Should we use `$/` record separator instead?
  #
  # source://ansi//lib/ansi/diff.rb#56
  def to_s; end

  private

  # Oh, I should have documented this will I knew what the
  # hell it was doing ;)
  #
  # source://ansi//lib/ansi/diff.rb#139
  def common(x, y); end

  # Take two plain strings and produce colorized
  # versions of each highlighting their differences.
  #
  # @param x [String] First string to compare.
  # @param y [String] Second string to compare.
  # @return [Array<String>] The two difference strings.
  #
  # source://ansi//lib/ansi/diff.rb#120
  def compare(x, y); end

  # Ensure the object of comparison is a string. If +object+ is not
  # an instance of String then it wll be converted to one by calling
  # either #to_str, if the object responds to it, or #inspect.
  #
  # source://ansi//lib/ansi/diff.rb#97
  def convert(object); end

  # Take two plain strings and produce colorized
  # versions of each highlighting their differences.
  #
  # @param string1 [String] First string to compare.
  # @param string2 [String] Second string to compare.
  # @return [Array<String>] The two difference strings.
  #
  # source://ansi//lib/ansi/diff.rb#90
  def diff_string(string1, string2); end

  # Least common string.
  #
  # source://ansi//lib/ansi/diff.rb#168
  def lcs(s1, s2); end

  # Hmm... is this even useful?
  #
  # source://ansi//lib/ansi/diff.rb#197
  def lcs_size(s1, s2); end

  class << self
    # Highlights the differnce between two strings.
    #
    # This class method is equivalent to calling:
    #
    #   ANSI::Diff.new(object1, object2).to_a
    #
    # source://ansi//lib/ansi/diff.rb#15
    def diff(object1, object2, options = T.unsafe(nil)); end
  end
end

# Rotation of colors for diff output.
#
# source://ansi//lib/ansi/diff.rb#108
ANSI::Diff::COLORS = T.let(T.unsafe(nil), Array)

# = ANSI::Logger
#
# Extended variation of Ruby's standard Logger library that supports
# color output.
#
#   log = ANSI::Logger.new
#
#   log.formatter do |severity, timestamp, progname, msg|
#     ANSI::Logger::SIMPLE_FORMAT % [severity, msg]
#   end
#
# --
# TODO: What's all this about then?
#
# When using debug level logger messages always append 'if $DBG'
# at the end. This hack is needed because Ruby does not support
# lazy evaluation (lisp macros).
# ++
#
# source://ansi//lib/ansi/logger.rb#27
class ANSI::Logger < ::Logger
  # source://ansi//lib/ansi/logger.rb#50
  def ansicolor=(on); end

  # @return [Boolean]
  #
  # source://ansi//lib/ansi/logger.rb#45
  def ansicolor?; end

  # source://ansi//lib/ansi/logger.rb#97
  def debug(progname = T.unsafe(nil), &block); end

  # source://ansi//lib/ansi/logger.rb#103
  def error(progname = T.unsafe(nil), &block); end

  # source://ansi//lib/ansi/logger.rb#109
  def fatal(progname = T.unsafe(nil), &block); end

  # Dictate the way in which this logger should format the
  # messages it displays. This method requires a block. The
  # block should return formatted strings given severity,
  # timestamp, progname and msg.
  #
  # === Example
  #
  #   logger = ANSI::Logger.new
  #
  #   logger.formatter do |severity, timestamp, progname, msg|
  #     "#{progname}@#{timestamp} - #{severity}::#{msg}"
  #   end
  #
  # source://ansi//lib/ansi/logger.rb#67
  def formatter(&block); end

  # source://ansi//lib/ansi/logger.rb#85
  def info(progname = T.unsafe(nil), &block); end

  # source://ansi//lib/ansi/logger.rb#72
  def styles(options = T.unsafe(nil)); end

  # source://ansi//lib/ansi/logger.rb#91
  def warn(progname = T.unsafe(nil), &block); end

  private

  # :yield:
  #
  # source://ansi//lib/ansi/logger.rb#134
  def debug_with_color; end

  # :yield:
  #
  # source://ansi//lib/ansi/logger.rb#128
  def error_with_color; end

  # :yield:
  #
  # source://ansi//lib/ansi/logger.rb#140
  def fatal_with_color; end

  # :yield:
  #
  # source://ansi//lib/ansi/logger.rb#116
  def info_with_color; end

  # :yield:
  #
  # source://ansi//lib/ansi/logger.rb#122
  def warn_with_color; end
end

# source://ansi//lib/ansi/logger.rb#31
ANSI::Logger::DETAILED_FORMAT = T.let(T.unsafe(nil), String)

# Some available logging formats.
#
# source://ansi//lib/ansi/logger.rb#30
ANSI::Logger::SIMPLE_FORMAT = T.let(T.unsafe(nil), String)

# This module is designed specifically for mixing into
# String-like classes or extending String-like objects.
#
# Generally speaking the String#ansi method is the more
# elegant approach to modifying a string with codes
# via a method call. But in some cases this Mixin's design
# might be preferable. Indeed, it original intent was
# as a compatability layer for the +colored+ gem.
#
# source://ansi//lib/ansi/mixin.rb#13
module ANSI::Mixin
  # source://ansi//lib/ansi/mixin.rb#27
  def black; end

  # source://ansi//lib/ansi/mixin.rb#48
  def black_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#50
  def black_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#46
  def black_on_green; end

  # source://ansi//lib/ansi/mixin.rb#49
  def black_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#45
  def black_on_red; end

  # source://ansi//lib/ansi/mixin.rb#51
  def black_on_white; end

  # source://ansi//lib/ansi/mixin.rb#47
  def black_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#20
  def blink; end

  # source://ansi//lib/ansi/mixin.rb#31
  def blue; end

  # source://ansi//lib/ansi/mixin.rb#77
  def blue_on_black; end

  # source://ansi//lib/ansi/mixin.rb#82
  def blue_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#79
  def blue_on_green; end

  # source://ansi//lib/ansi/mixin.rb#81
  def blue_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#78
  def blue_on_red; end

  # source://ansi//lib/ansi/mixin.rb#83
  def blue_on_white; end

  # source://ansi//lib/ansi/mixin.rb#80
  def blue_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#15
  def bold; end

  # source://ansi//lib/ansi/mixin.rb#24
  def concealed; end

  # source://ansi//lib/ansi/mixin.rb#33
  def cyan; end

  # source://ansi//lib/ansi/mixin.rb#93
  def cyan_on_black; end

  # source://ansi//lib/ansi/mixin.rb#97
  def cyan_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#95
  def cyan_on_green; end

  # source://ansi//lib/ansi/mixin.rb#98
  def cyan_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#94
  def cyan_on_red; end

  # source://ansi//lib/ansi/mixin.rb#99
  def cyan_on_white; end

  # source://ansi//lib/ansi/mixin.rb#96
  def cyan_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#16
  def dark; end

  # Move cursor to line and column, insert +self.to_s+ and return to
  # original positon.
  #
  # source://ansi//lib/ansi/mixin.rb#111
  def display(line, column = T.unsafe(nil)); end

  # source://ansi//lib/ansi/mixin.rb#29
  def green; end

  # source://ansi//lib/ansi/mixin.rb#61
  def green_on_black; end

  # source://ansi//lib/ansi/mixin.rb#64
  def green_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#66
  def green_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#65
  def green_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#62
  def green_on_red; end

  # source://ansi//lib/ansi/mixin.rb#67
  def green_on_white; end

  # source://ansi//lib/ansi/mixin.rb#63
  def green_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#17
  def italic; end

  # source://ansi//lib/ansi/mixin.rb#32
  def magenta; end

  # source://ansi//lib/ansi/mixin.rb#85
  def magenta_on_black; end

  # source://ansi//lib/ansi/mixin.rb#89
  def magenta_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#90
  def magenta_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#87
  def magenta_on_green; end

  # source://ansi//lib/ansi/mixin.rb#86
  def magenta_on_red; end

  # source://ansi//lib/ansi/mixin.rb#91
  def magenta_on_white; end

  # source://ansi//lib/ansi/mixin.rb#88
  def magenta_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#23
  def negative; end

  # source://ansi//lib/ansi/mixin.rb#36
  def on_black; end

  # source://ansi//lib/ansi/mixin.rb#40
  def on_blue; end

  # source://ansi//lib/ansi/mixin.rb#42
  def on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#38
  def on_green; end

  # source://ansi//lib/ansi/mixin.rb#41
  def on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#37
  def on_red; end

  # source://ansi//lib/ansi/mixin.rb#43
  def on_white; end

  # source://ansi//lib/ansi/mixin.rb#39
  def on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#21
  def rapid; end

  # source://ansi//lib/ansi/mixin.rb#28
  def red; end

  # source://ansi//lib/ansi/mixin.rb#53
  def red_on_black; end

  # source://ansi//lib/ansi/mixin.rb#56
  def red_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#58
  def red_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#54
  def red_on_green; end

  # source://ansi//lib/ansi/mixin.rb#57
  def red_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#59
  def red_on_white; end

  # source://ansi//lib/ansi/mixin.rb#55
  def red_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#22
  def reverse; end

  # source://ansi//lib/ansi/mixin.rb#25
  def strike; end

  # source://ansi//lib/ansi/mixin.rb#18
  def underline; end

  # source://ansi//lib/ansi/mixin.rb#19
  def underscore; end

  # source://ansi//lib/ansi/mixin.rb#34
  def white; end

  # source://ansi//lib/ansi/mixin.rb#101
  def white_on_black; end

  # source://ansi//lib/ansi/mixin.rb#105
  def white_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#107
  def white_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#103
  def white_on_green; end

  # source://ansi//lib/ansi/mixin.rb#106
  def white_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#102
  def white_on_red; end

  # source://ansi//lib/ansi/mixin.rb#104
  def white_on_yellow; end

  # source://ansi//lib/ansi/mixin.rb#30
  def yellow; end

  # source://ansi//lib/ansi/mixin.rb#69
  def yellow_on_black; end

  # source://ansi//lib/ansi/mixin.rb#72
  def yellow_on_blue; end

  # source://ansi//lib/ansi/mixin.rb#74
  def yellow_on_cyan; end

  # source://ansi//lib/ansi/mixin.rb#71
  def yellow_on_green; end

  # source://ansi//lib/ansi/mixin.rb#73
  def yellow_on_magenta; end

  # source://ansi//lib/ansi/mixin.rb#70
  def yellow_on_red; end

  # source://ansi//lib/ansi/mixin.rb#75
  def yellow_on_white; end
end

# = Progressbar
#
# Progressbar is a text-based progressbar library.
#
#   pbar = Progressbar.new( "Demo", 100 )
#   100.times { pbar.inc }
#   pbar.finish
#
# source://ansi//lib/ansi/progressbar.rb#20
class ANSI::ProgressBar
  # @return [ProgressBar] a new instance of ProgressBar
  #
  # source://ansi//lib/ansi/progressbar.rb#22
  def initialize(title, total, out = T.unsafe(nil)); end

  # source://ansi//lib/ansi/progressbar.rb#54
  def bar_mark=(mark); end

  # source://ansi//lib/ansi/progressbar.rb#54
  def barmark=(mark); end

  # source://ansi//lib/ansi/progressbar.rb#138
  def clear; end

  # For backward compatability
  #
  # source://ansi//lib/ansi/progressbar.rb#85
  def file_transfer_mode; end

  # source://ansi//lib/ansi/progressbar.rb#93
  def finish; end

  # source://ansi//lib/ansi/progressbar.rb#99
  def flush; end

  # Set format and format arguments.
  #
  # source://ansi//lib/ansi/progressbar.rb#68
  def format(format, *arguments); end

  # Sets the attribute format
  #
  # @param value the value to set the attribute format to.
  #
  # source://ansi//lib/ansi/progressbar.rb#45
  def format=(_arg0); end

  # Returns the value of attribute format_arguments.
  #
  # source://ansi//lib/ansi/progressbar.rb#46
  def format_arguments; end

  # Sets the attribute format_arguments
  #
  # @param value the value to set the attribute format_arguments to.
  #
  # source://ansi//lib/ansi/progressbar.rb#46
  def format_arguments=(_arg0); end

  # source://ansi//lib/ansi/progressbar.rb#103
  def halt; end

  # source://ansi//lib/ansi/progressbar.rb#130
  def inc(step = T.unsafe(nil)); end

  # source://ansi//lib/ansi/progressbar.rb#142
  def inspect; end

  # source://ansi//lib/ansi/progressbar.rb#54
  def mark=(mark); end

  # source://ansi//lib/ansi/progressbar.rb#124
  def reset; end

  # source://ansi//lib/ansi/progressbar.rb#108
  def set(count); end

  # source://ansi//lib/ansi/progressbar.rb#79
  def standard_mode; end

  # Set ANSI styling options.
  #
  # source://ansi//lib/ansi/progressbar.rb#74
  def style(options); end

  # Returns the value of attribute styles.
  #
  # source://ansi//lib/ansi/progressbar.rb#47
  def styles; end

  # Sets the attribute styles
  #
  # @param value the value to set the attribute styles to.
  #
  # source://ansi//lib/ansi/progressbar.rb#47
  def styles=(_arg0); end

  # source://ansi//lib/ansi/progressbar.rb#50
  def title=(str); end

  # source://ansi//lib/ansi/progressbar.rb#60
  def total_overflow=(boolv); end

  # source://ansi//lib/ansi/progressbar.rb#85
  def transfer_mode; end

  private

  # source://ansi//lib/ansi/progressbar.rb#210
  def bar; end

  # source://ansi//lib/ansi/progressbar.rb#166
  def bytes; end

  # source://ansi//lib/ansi/progressbar.rb#280
  def colorize(part, style); end

  # source://ansi//lib/ansi/progressbar.rb#149
  def convert_bytes(bytes); end

  # source://ansi//lib/ansi/progressbar.rb#189
  def elapsed; end

  # source://ansi//lib/ansi/progressbar.rb#206
  def eol; end

  # ETA stands for Estimated Time of Arrival.
  #
  # source://ansi//lib/ansi/progressbar.rb#179
  def eta; end

  # source://ansi//lib/ansi/progressbar.rb#170
  def format_time(t); end

  # TODO: Use Terminal.terminal_width instead.
  #
  # source://ansi//lib/ansi/progressbar.rb#228
  def get_width; end

  # source://ansi//lib/ansi/progressbar.rb#215
  def percentage; end

  # source://ansi//lib/ansi/progressbar.rb#247
  def show; end

  # source://ansi//lib/ansi/progressbar.rb#266
  def show_progress; end

  # source://ansi//lib/ansi/progressbar.rb#194
  def stat; end

  # source://ansi//lib/ansi/progressbar.rb#198
  def stat_for_file_transfer; end

  # source://ansi//lib/ansi/progressbar.rb#223
  def title; end

  # source://ansi//lib/ansi/progressbar.rb#161
  def transfer_rate; end
end

# source://ansi//lib/ansi/progressbar.rb#289
ANSI::Progressbar = ANSI::ProgressBar

# source://ansi//lib/ansi/chart.rb#86
ANSI::SPECIAL_CHART = T.let(T.unsafe(nil), Hash)

# IMPORTANT! ANSI::String is experimental!!!
#
# ANSI::String stores a regular string (`@text`) and an associative
# array that ties a character index to an ANSI code (`marks`).
# For example is we have the string:
#
#   "Big Apple"
#
# And applied the color red to it, the marks list would be:
#
#   [[0, :red], [9, :clear]]
#
# TODO: In the future we may be able to subclass String,
# instead of delegating via @text, but not until it is more
# compatible.
#
# source://ansi//lib/ansi/string.rb#25
class ANSI::String
  # New Ansi::String
  #
  # @return [String] a new instance of String
  # @yield [_self]
  # @yieldparam _self [ANSI::String] the object that the method was called on
  #
  # source://ansi//lib/ansi/string.rb#33
  def initialize(text = T.unsafe(nil), marks = T.unsafe(nil)); end

  # Add one String to another, or to a regular String.
  #
  # source://ansi//lib/ansi/string.rb#73
  def +(other); end

  # slice
  #
  # source://ansi//lib/ansi/string.rb#98
  def [](*args); end

  # source://ansi//lib/ansi/string.rb#194
  def ansi(code); end

  # source://ansi//lib/ansi/string.rb#204
  def ansi!(code); end

  # source://ansi//lib/ansi/string.rb#214
  def black; end

  # source://ansi//lib/ansi/string.rb#225
  def black!; end

  # source://ansi//lib/ansi/string.rb#213
  def blue; end

  # source://ansi//lib/ansi/string.rb#224
  def blue!; end

  # source://ansi//lib/ansi/string.rb#219
  def bold; end

  # source://ansi//lib/ansi/string.rb#230
  def bold!; end

  # source://ansi//lib/ansi/string.rb#194
  def color(code); end

  # source://ansi//lib/ansi/string.rb#204
  def color!(code); end

  # source://ansi//lib/ansi/string.rb#217
  def cyan; end

  # source://ansi//lib/ansi/string.rb#228
  def cyan!; end

  # Downcase the string.
  #
  # source://ansi//lib/ansi/string.rb#69
  def downcase; end

  # source://ansi//lib/ansi/string.rb#70
  def downcase!; end

  # source://ansi//lib/ansi/string.rb#212
  def green; end

  # source://ansi//lib/ansi/string.rb#223
  def green!; end

  # See #gsub!.
  #
  # source://ansi//lib/ansi/string.rb#189
  def gsub(pattern, replacement = T.unsafe(nil), &block); end

  # source://ansi//lib/ansi/string.rb#163
  def gsub!(pattern, replacement = T.unsafe(nil), &block); end

  # source://ansi//lib/ansi/string.rb#215
  def magenta; end

  # source://ansi//lib/ansi/string.rb#226
  def magenta!; end

  # Returns the value of attribute marks.
  #
  # source://ansi//lib/ansi/string.rb#30
  def marks; end

  # source://ansi//lib/ansi/string.rb#211
  def red; end

  # source://ansi//lib/ansi/string.rb#222
  def red!; end

  # The size of the base text.
  #
  # source://ansi//lib/ansi/string.rb#62
  def size; end

  # slice
  #
  # source://ansi//lib/ansi/string.rb#98
  def slice(*args); end

  # See #sub!.
  #
  # source://ansi//lib/ansi/string.rb#158
  def sub(pattern, replacement = T.unsafe(nil), &block); end

  # This is more limited than the normal String method.
  # It does not yet support a block, and +replacement+
  # won't substitue for \1, \2, etc.
  #
  # TODO: block support.
  #
  # source://ansi//lib/ansi/string.rb#139
  def sub!(pattern, replacement = T.unsafe(nil), &block); end

  # Returns the value of attribute text.
  #
  # source://ansi//lib/ansi/string.rb#29
  def text; end

  # Convert Ansi::String object to normal String.
  # This converts the intental markup codes to ANSI codes.
  #
  # source://ansi//lib/ansi/string.rb#41
  def to_s; end

  # Convert Ansi::String object to normal String.
  # This converts the intental markup codes to ANSI codes.
  # ANSI::String is a type of String.
  #
  # source://ansi//lib/ansi/string.rb#41
  def to_str; end

  # source://ansi//lib/ansi/string.rb#220
  def underline; end

  # source://ansi//lib/ansi/string.rb#231
  def underline!; end

  # Upcase the string.
  #
  # source://ansi//lib/ansi/string.rb#65
  def upcase; end

  # source://ansi//lib/ansi/string.rb#66
  def upcase!; end

  # source://ansi//lib/ansi/string.rb#216
  def yellow; end

  # source://ansi//lib/ansi/string.rb#227
  def yellow!; end

  private

  # source://ansi//lib/ansi/string.rb#236
  def shift_marks(index, delta, marks = T.unsafe(nil)); end

  # source://ansi//lib/ansi/string.rb#250
  def shift_marks!(index, delta); end
end

# source://ansi//lib/ansi/string.rb#27
ANSI::String::CLR = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/table.rb#6
class ANSI::Table
  # The Table class can be used to output nicely formatted
  # tables with division lines and alignment.
  #
  # table - array of array
  #
  # options[:align]   - align :left or :right
  # options[:padding] - space to add to each cell
  # options[:fit]     - fit to screen width
  # options[:border]  -
  #
  # The +format+ block must return ANSI codes to apply
  # to each cell.
  #
  # Other Implementations:
  #
  # * http://github.com/visionmedia/terminal-table
  # * http://github.com/aptinio/text-table
  #
  # TODO: Support for table headers and footers.
  #
  # @return [Table] a new instance of Table
  #
  # source://ansi//lib/ansi/table.rb#27
  def initialize(table, options = T.unsafe(nil), &format); end

  # Returns the value of attribute align.
  #
  # source://ansi//lib/ansi/table.rb#49
  def align; end

  # Sets the attribute align
  #
  # @param value the value to set the attribute align to.
  #
  # source://ansi//lib/ansi/table.rb#49
  def align=(_arg0); end

  # Returns the value of attribute border.
  #
  # source://ansi//lib/ansi/table.rb#55
  def border; end

  # Sets the attribute border
  #
  # @param value the value to set the attribute border to.
  #
  # source://ansi//lib/ansi/table.rb#55
  def border=(_arg0); end

  # Fit to scree width.
  #
  # source://ansi//lib/ansi/table.rb#43
  def fit; end

  # Fit to scree width.
  #
  # source://ansi//lib/ansi/table.rb#43
  def fit=(_arg0); end

  # Returns the value of attribute format.
  #
  # source://ansi//lib/ansi/table.rb#52
  def format; end

  # Sets the attribute format
  #
  # @param value the value to set the attribute format to.
  #
  # source://ansi//lib/ansi/table.rb#52
  def format=(_arg0); end

  # Returns the value of attribute padding.
  #
  # source://ansi//lib/ansi/table.rb#46
  def padding; end

  # Sets the attribute padding
  #
  # @param value the value to set the attribute padding to.
  #
  # source://ansi//lib/ansi/table.rb#46
  def padding=(_arg0); end

  # Returns the value of attribute table.
  #
  # source://ansi//lib/ansi/table.rb#40
  def table; end

  # Sets the attribute table
  #
  # @param value the value to set the attribute table to.
  #
  # source://ansi//lib/ansi/table.rb#40
  def table=(_arg0); end

  # (fit=false)
  #
  # source://ansi//lib/ansi/table.rb#58
  def to_s; end

  private

  # source://ansi//lib/ansi/table.rb#158
  def ansi_formating(cell, col, row); end

  # source://ansi//lib/ansi/table.rb#149
  def apply_format(str, cell, col, row); end

  # source://ansi//lib/ansi/table.rb#123
  def cell_template(max); end

  # Number of columns based on the first row of table.
  #
  # @return [Integer] number of columns
  #
  # source://ansi//lib/ansi/table.rb#118
  def column_size; end

  # TODO: make more efficient
  #
  # source://ansi//lib/ansi/table.rb#133
  def dividing_line; end

  # TODO: look at the lines and figure out how many columns will fit
  #
  # source://ansi//lib/ansi/table.rb#91
  def fit_width; end

  # Calculate the maximun column sizes.
  #
  # @return [Array] maximum size for each column
  #
  # source://ansi//lib/ansi/table.rb#99
  def max_columns(fit = T.unsafe(nil)); end
end

# source://ansi//lib/ansi/terminal.rb#13
module ANSI::Terminal
  private

  # Windows savvy getc().
  #
  # source://ansi//lib/ansi/terminal/stty.rb#16
  def get_character(input = T.unsafe(nil)); end

  # Switched the input mode to raw and disables echo.
  #
  # *WARNING*:  This method requires the external "stty" program!
  #
  # source://ansi//lib/ansi/terminal/stty.rb#31
  def raw_no_echo_mode; end

  # Restores a previously saved input mode.
  #
  # *WARNING*:  This method requires the external "stty" program!
  #
  # source://ansi//lib/ansi/terminal/stty.rb#41
  def restore_mode; end

  # Get the height of the terminal window.
  #
  # source://ansi//lib/ansi/terminal.rb#37
  def terminal_height; end

  # A Windows savvy method to fetch the console columns, and rows.
  #
  # source://ansi//lib/ansi/terminal/stty.rb#46
  def terminal_size; end

  # Get the width of the terminal window.
  #
  # source://ansi//lib/ansi/terminal.rb#32
  def terminal_width; end

  class << self
    # Windows savvy getc().
    #
    # source://ansi//lib/ansi/terminal/stty.rb#16
    def get_character(input = T.unsafe(nil)); end

    # Switched the input mode to raw and disables echo.
    #
    # *WARNING*:  This method requires the external "stty" program!
    #
    # source://ansi//lib/ansi/terminal/stty.rb#31
    def raw_no_echo_mode; end

    # Restores a previously saved input mode.
    #
    # *WARNING*:  This method requires the external "stty" program!
    #
    # source://ansi//lib/ansi/terminal/stty.rb#41
    def restore_mode; end

    # Get the height of the terminal window.
    #
    # source://ansi//lib/ansi/terminal.rb#37
    def terminal_height; end

    # A Windows savvy method to fetch the console columns, and rows.
    #
    # source://ansi//lib/ansi/terminal/stty.rb#46
    def terminal_size; end

    # Get the width of the terminal window.
    #
    # source://ansi//lib/ansi/terminal.rb#32
    def terminal_width; end
  end
end

# source://ansi//lib/ansi/terminal.rb#26
ANSI::Terminal::CHARACTER_MODE = T.let(T.unsafe(nil), String)

# source://ansi//lib/ansi/logger.rb#35
class Logger::LogDevice
  # source://ansi//lib/ansi/logger.rb#36
  def ansicolor=(_arg0); end

  # @return [Boolean]
  #
  # source://ansi//lib/ansi/logger.rb#38
  def ansicolor?; end
end

class Object < ::BasicObject
  include ::Kernel
  include ::PP::ObjectMixin

  private

  # source://ansi//lib/ansi.rb#19
  def ansi(string, *codes); end
end

# source://ansi//lib/ansi/core.rb#4
class String
  include ::Comparable

  # source://ansi//lib/ansi/core.rb#7
  def ansi(*codes); end

  # source://ansi//lib/ansi/core.rb#16
  def ansi!(*codes); end

  # source://ansi//lib/ansi/core.rb#21
  def unansi; end

  # source://ansi//lib/ansi/core.rb#26
  def unansi!; end
end
